title: python的垃圾回收
author: hero576
tags:
  - python
categories:
  - python
date: 2017-10-16 20:48:00
---
现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。

python里每一个东西都是对象，它们的核心就是一个结构体：PyObject
```python
typedef struct_object {
int ob_refcnt;
struct_typeobject *ob_type;
}PyObject;
```
## 引用计数机制

PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少

引用计数为0时，该对象生命就结束了。

引用计数机制的优点：
1. 简单
2. 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。        

引用计数机制的缺点： 
1. 维护引用计数消耗资源 
2. 如果出现循环引用的话，引用计数机制就不在起有效作用了。

```python
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。

对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。

## 标记-清除机制

如果两个对象的引用计数都为1，但是仅仅存在她们之间的循环引用，那么这两个对象都是需要被回收的，也就是说他们的引用计数虽然表现为非0，但实际有效的引用计数为0。所以现将循环引用摘掉，就会得出对象的有用计数。

缺点：该机制所带来的额外操作和需要回收的内存块成正比。


## 分代回收
从“标记-清除”的垃圾回收机制来看，当需要回收的内存块较多时，垃圾检测带来的额外操作会增多，而垃圾回收带来的额外操作就越少。反之，内存块较多时，垃圾检测就比垃圾回收带来更少的额外操作。

### 内存池

1. Python的内存机制呈现金字塔形状，-1，-2层主要有操作系统进行操作；
2. 第0层是C中的malloc,free等内存分配和释放函数进行操作；
3. 第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
4. 第3层是最上层，也就是我们对Python对象的直接操作；

Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

Python内部默认的小块内存与大块内存的分界点定在256个字节，当申请的内存小于256字节时，PyObject_Malloc会在内存池中申请内存；当申请的内存大于256字节时，PyObject_Malloc的行为将蜕化为malloc的行为。

当然，通过修改Python源代码，我们可以改变这个默认值，从而改变Python的默认内存管理行为。有时间可以仔细看看[一篇垃圾回收讲解比较详细文章](https://www.jianshu.com/p/1e375fb40506)
